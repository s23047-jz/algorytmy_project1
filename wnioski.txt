Wnioski o przeprowadzaniu testow algorytmow sortujacych.

Najszybszym algorytmem okazal sie merge sort. Jego schemat zostal umieszczony w jednej funkcji przez co jest bardziej przejrzysty i nie trzeba szukac pozostalych funkcji wywolujacych.

Na drugie miejsce zakwalifikowal sie heap sort. Patrzac na czas wykonywania danych funkcji mozna powiedziec ze jest praktycznie dwa razy wolniejszy od merge sorta.

Na trzecim ku zaskoczeniu quick-sort. Mimo wszystko dla wiekszych tablic czas wykonania jest znaczaco wiekszy niz w poprzednich dwoch. W porownaniu do heap sorta gdzie czas wykonania siegal okolo 7 sekund, quick sort uzyskal wynik dla takiej samem talicy czas 149 sekund. Uwazam ze to mniejszych danych sie sprawdzi, ale jesli chodzi o wieksze dane zamienilbym go na heap lub merge.

Ostatnie bez zaskoczenia dostaje bubble sort. Dlugie sortowanie jest wynikiem sprawdzania wielokrotnie dwa znajdujace sie obok siebie obiekty tablicy, sprawdza i tak ciagle az nie dojdzie do konca, i znowu na nowo przejscie do poczatku. Sprawdzilem jedynie czy algorytm dobrze sortuje na tablicy długości rownej 10. Dla wiekszych tablic poddalem sie po 2 godzinach, stwierdzilem ze nie ma sensu tracic na to czasu.

Chcialem rowniez zaprezentowac algorytm sortujacy drzewem binarnym ktorego uzywam w pracy glownie do przeszukiwania. Niestety pojawil sie problem, ze nie mialem pomyslu na to aby nadpisac tablice. Pozostalo jedynie testowac za pomoca wypisywania wartosci w konsoli.
Jednakże czas wykonania sortowania byl 8-9 razy wiekszy od merge czy 3.5-4 razy wiekszy od heap.

Ostatecznie zamienilbym quick sorta na binary tree sort'a. Roznica czasowa jest znaczaca. Oczywiscie dopiero po udaje probie zaimplementowania wlasciwie dzialajacego algorytmu.

Rodzaje funkcji:

Merge, heap, quick oraz binary tree sort -> liniowa.
bubble sort -> kwadratowa (poza skala)
